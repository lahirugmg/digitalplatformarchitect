'use client'

import { useState } from 'react'
import { type PatternNode, type CompositionValidation } from '@/lib/pattern-compatibility'

interface ExportModalProps {
  patterns: PatternNode[]
  validation: CompositionValidation
  onClose: () => void
}

type ExportFormat = 'architecture-doc' | 'terraform' | 'kubernetes' | 'adr'

export default function ExportModal({ patterns, validation, onClose }: ExportModalProps) {
  const [selectedFormat, setSelectedFormat] = useState<ExportFormat>('architecture-doc')
  const [copied, setCopied] = useState(false)

  const generateArchitectureDoc = (): string => {
    const timestamp = new Date().toISOString().split('T')[0]

    let doc = `# Architecture Composition Document
Generated: ${timestamp}

## Overview

This architecture composition combines ${patterns.length} architectural patterns to create a comprehensive solution.

## Patterns Used

${patterns.map(p => `### ${p.icon} ${p.title}
**Category:** ${p.category}
**Description:** ${p.description}

**Characteristics:**
${Object.entries(p.characteristics)
  .map(([key, value]) => `- ${key}: ${value}`)
  .join('\n')}

**Tags:** ${p.tags.join(', ')}
`).join('\n')}

## Validation Results

### Status
${validation.isValid ? 'âœ… Composition is valid' : 'âŒ Conflicts detected'}

${validation.synergies.length > 0 ? `### âœ¨ Synergies (${validation.synergies.length})

${validation.synergies.map(s =>
  `- **${getPatternName(s.pattern1)} + ${getPatternName(s.pattern2)}**
  ${s.reason}
  ðŸ’¡ ${s.recommendation || 'No additional recommendations'}`
).join('\n\n')}
` : ''}

${validation.warnings.length > 0 ? `### âš ï¸ Warnings (${validation.warnings.length})

${validation.warnings.map(w =>
  `- **${getPatternName(w.pattern1)} + ${getPatternName(w.pattern2)}**
  ${w.reason}
  ðŸ’¡ ${w.recommendation || 'Review carefully'}`
).join('\n\n')}
` : ''}

${validation.conflicts.length > 0 ? `### âŒ Conflicts (${validation.conflicts.length})

${validation.conflicts.map(c =>
  `- **${getPatternName(c.pattern1)} + ${getPatternName(c.pattern2)}**
  ${c.reason}
  ðŸ’¡ ${c.recommendation || 'Consider removing one of these patterns'}`
).join('\n\n')}
` : ''}

${validation.recommendations.length > 0 ? `### ðŸ’¡ General Recommendations

${validation.recommendations.map(r => `- ${r}`).join('\n')}
` : ''}

## Implementation Considerations

### Technology Stack Recommendations

${generateTechStackRecommendations()}

### Next Steps

1. Review and resolve any conflicts identified above
2. Implement patterns in dependency order (foundations first)
3. Set up monitoring and observability for all components
4. Create detailed design documents for each pattern
5. Plan phased rollout strategy

---

*Generated by Digital Platform Architect - Pattern Composer*
`
    return doc
  }

  const generateTerraform = (): string => {
    return `# Terraform Configuration for Architecture Composition
# Generated: ${new Date().toISOString().split('T')[0]}
# Patterns: ${patterns.map(p => p.title).join(', ')}

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "dev"
}

variable "project_name" {
  description = "Project name"
  type        = string
  default     = "architecture-composition"
}

# Pattern-based infrastructure components

${patterns.map(p => generateTerraformForPattern(p)).join('\n\n')}

# Outputs

output "architecture_summary" {
  description = "Summary of deployed architecture"
  value = {
    patterns = ${JSON.stringify(patterns.map(p => p.title))}
    environment = var.environment
  }
}
`
  }

  const generateTerraformForPattern = (pattern: PatternNode): string => {
    const sanitizedId = pattern.id.replace(/-/g, '_')

    switch (pattern.id) {
      case 'api-gateway':
        return `# API Gateway
resource "aws_api_gateway_rest_api" "${sanitizedId}" {
  name        = "\${var.project_name}-\${var.environment}-api"
  description = "API Gateway for ${pattern.title}"

  endpoint_configuration {
    types = ["REGIONAL"]
  }
}`

      case 'event-sourcing':
        return `# Event Sourcing - Event Store
resource "aws_dynamodb_table" "${sanitizedId}_events" {
  name           = "\${var.project_name}-\${var.environment}-events"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "aggregate_id"
  range_key      = "version"

  attribute {
    name = "aggregate_id"
    type = "S"
  }

  attribute {
    name = "version"
    type = "N"
  }

  stream_enabled   = true
  stream_view_type = "NEW_AND_OLD_IMAGES"
}`

      case 'microservices':
        return `# Microservices - ECS Cluster
resource "aws_ecs_cluster" "${sanitizedId}" {
  name = "\${var.project_name}-\${var.environment}-cluster"

  setting {
    name  = "containerInsights"
    value = "enabled"
  }
}`

      default:
        return `# ${pattern.title}
# TODO: Implement infrastructure for ${pattern.id}
# Characteristics: ${Object.entries(pattern.characteristics).map(([k, v]) => `${k}=${v}`).join(', ')}`
    }
  }

  const generateKubernetes = (): string => {
    return `# Kubernetes Manifests for Architecture Composition
# Generated: ${new Date().toISOString().split('T')[0]}
# Patterns: ${patterns.map(p => p.title).join(', ')}

---
apiVersion: v1
kind: Namespace
metadata:
  name: architecture-composition
  labels:
    environment: dev
    managed-by: pattern-composer

${patterns.map(p => generateK8sForPattern(p)).join('\n\n---\n\n')}
`
  }

  const generateK8sForPattern = (pattern: PatternNode): string => {
    const sanitizedName = pattern.id

    switch (pattern.id) {
      case 'api-gateway':
        return `apiVersion: v1
kind: Service
metadata:
  name: api-gateway
  namespace: architecture-composition
  labels:
    app: api-gateway
    pattern: ${pattern.id}
spec:
  type: LoadBalancer
  selector:
    app: api-gateway
  ports:
    - port: 80
      targetPort: 8080
      protocol: TCP

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-gateway
  namespace: architecture-composition
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api-gateway
  template:
    metadata:
      labels:
        app: api-gateway
        pattern: ${pattern.id}
    spec:
      containers:
      - name: gateway
        image: nginx:latest  # Replace with actual API gateway image
        ports:
        - containerPort: 8080`

      case 'circuit-breaker':
        return `apiVersion: v1
kind: ConfigMap
metadata:
  name: circuit-breaker-config
  namespace: architecture-composition
data:
  config.yaml: |
    circuitBreaker:
      failureThreshold: 5
      successThreshold: 2
      timeout: 60s
      halfOpenRequests: 3`

      default:
        return `# ${pattern.title} (${pattern.id})
# TODO: Define Kubernetes resources for this pattern
# Category: ${pattern.category}
# Description: ${pattern.description}`
    }
  }

  const generateADR = (): string => {
    const timestamp = new Date().toISOString().split('T')[0]

    return `# ADR: Architecture Pattern Composition

**Date:** ${timestamp}
**Status:** Proposed
**Deciders:** Architecture Team

## Context

We need to design a system architecture that addresses our requirements while following established architectural patterns and best practices.

## Decision

We will compose our architecture using the following ${patterns.length} architectural patterns:

${patterns.map((p, i) => `${i + 1}. **${p.title}** (${p.category}): ${p.description}`).join('\n')}

## Rationale

### Pattern Synergies

${validation.synergies.length > 0 ? validation.synergies.map(s =>
  `- **${getPatternName(s.pattern1)} + ${getPatternName(s.pattern2)}:** ${s.reason}`
).join('\n') : '_No specific synergies identified_'}

### Considerations and Trade-offs

${validation.warnings.length > 0 ? validation.warnings.map(w =>
  `- **${getPatternName(w.pattern1)} + ${getPatternName(w.pattern2)}:** ${w.reason}\n  Mitigation: ${w.recommendation || 'Review implementation carefully'}`
).join('\n\n') : '_No warnings identified_'}

${validation.conflicts.length > 0 ? `
### Conflicts to Resolve

${validation.conflicts.map(c =>
  `- **${getPatternName(c.pattern1)} + ${getPatternName(c.pattern2)}:** ${c.reason}\n  Resolution needed: ${c.recommendation || 'Choose one pattern or find alternative approach'}`
).join('\n\n')}
` : ''}

## Consequences

### Positive

- Leverages proven architectural patterns
- Clear separation of concerns
${validation.synergies.length > 0 ? `- Benefits from ${validation.synergies.length} identified pattern synergies` : ''}
- Well-documented and understood patterns

### Negative

${patterns.some(p => p.characteristics.complexity === 'high') ? '- Some patterns introduce significant complexity' : ''}
${validation.warnings.length > 0 ? `- ${validation.warnings.length} pattern combinations require careful implementation` : ''}
${validation.conflicts.length > 0 ? `- ${validation.conflicts.length} pattern conflicts need resolution` : ''}
- Requires team training on all selected patterns

## Implementation Notes

${validation.recommendations.length > 0 ? validation.recommendations.map(r => `- ${r}`).join('\n') : ''}

## References

- [Digital Platform Architect - Pattern Composer](/)
- Enterprise Integration Patterns by Gregor Hohpe
- Building Microservices by Sam Newman

---

*Generated by Digital Platform Architect - Pattern Composer*
`
  }

  const generateTechStackRecommendations = (): string => {
    const recommendations: string[] = []

    if (patterns.some(p => p.id === 'event-sourcing')) {
      recommendations.push('- **Event Store:** EventStoreDB, Apache Kafka, AWS DynamoDB Streams')
    }
    if (patterns.some(p => p.id === 'microservices')) {
      recommendations.push('- **Container Orchestration:** Kubernetes, AWS ECS, Docker Swarm')
    }
    if (patterns.some(p => p.id === 'api-gateway')) {
      recommendations.push('- **API Gateway:** Kong, AWS API Gateway, Apigee, Azure API Management')
    }
    if (patterns.some(p => p.category === 'Integration')) {
      recommendations.push('- **Integration Platform:** Apache Camel, WSO2 EI, MuleSoft')
    }
    if (patterns.some(p => p.id === 'circuit-breaker')) {
      recommendations.push('- **Resilience Library:** Resilience4j, Polly, Hystrix')
    }

    return recommendations.length > 0 ? recommendations.join('\n') : '- Evaluate based on specific requirements'
  }

  const getPatternName = (patternId: string): string => {
    const pattern = patterns.find(p => p.id === patternId)
    return pattern ? pattern.title : patternId
  }

  const getExportContent = (): string => {
    switch (selectedFormat) {
      case 'architecture-doc':
        return generateArchitectureDoc()
      case 'terraform':
        return generateTerraform()
      case 'kubernetes':
        return generateKubernetes()
      case 'adr':
        return generateADR()
      default:
        return ''
    }
  }

  const handleCopy = async () => {
    const content = getExportContent()
    await navigator.clipboard.writeText(content)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  const handleDownload = () => {
    const content = getExportContent()
    const extensions = {
      'architecture-doc': 'md',
      'terraform': 'tf',
      'kubernetes': 'yaml',
      'adr': 'md'
    }
    const filename = `architecture-composition.${extensions[selectedFormat]}`

    const blob = new Blob([content], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = filename
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  }

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-xl shadow-2xl max-w-4xl w-full max-h-[90vh] flex flex-col">
        {/* Header */}
        <div className="bg-gradient-to-r from-purple-600 to-indigo-600 text-white px-6 py-4 rounded-t-xl">
          <div className="flex justify-between items-center">
            <div>
              <h2 className="text-2xl font-bold mb-1">Export Architecture</h2>
              <p className="text-purple-100 text-sm">
                Generate documentation and infrastructure code
              </p>
            </div>
            <button
              onClick={onClose}
              className="text-white hover:bg-white/20 rounded-lg p-2 transition"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>

        {/* Format selector */}
        <div className="p-4 border-b border-slate-200 bg-slate-50">
          <div className="flex gap-2">
            <FormatButton
              format="architecture-doc"
              selected={selectedFormat === 'architecture-doc'}
              onClick={() => setSelectedFormat('architecture-doc')}
              icon="ðŸ“„"
              label="Architecture Doc"
            />
            <FormatButton
              format="terraform"
              selected={selectedFormat === 'terraform'}
              onClick={() => setSelectedFormat('terraform')}
              icon="ðŸ—ï¸"
              label="Terraform"
            />
            <FormatButton
              format="kubernetes"
              selected={selectedFormat === 'kubernetes'}
              onClick={() => setSelectedFormat('kubernetes')}
              icon="â˜¸ï¸"
              label="Kubernetes"
            />
            <FormatButton
              format="adr"
              selected={selectedFormat === 'adr'}
              onClick={() => setSelectedFormat('adr')}
              icon="ðŸ“‹"
              label="ADR"
            />
          </div>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-6">
          <pre className="bg-slate-900 text-green-400 p-4 rounded-lg text-xs font-mono overflow-x-auto whitespace-pre-wrap">
            {getExportContent()}
          </pre>
        </div>

        {/* Actions */}
        <div className="p-4 border-t border-slate-200 bg-slate-50 flex justify-between items-center rounded-b-xl">
          <div className="text-sm text-slate-600">
            {patterns.length} patterns â€¢ {selectedFormat.replace('-', ' ')}
          </div>
          <div className="flex gap-3">
            <button
              onClick={handleCopy}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition flex items-center gap-2"
            >
              {copied ? (
                <>
                  <span>âœ“</span>
                  Copied!
                </>
              ) : (
                <>
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                  </svg>
                  Copy
                </>
              )}
            </button>
            <button
              onClick={handleDownload}
              className="px-4 py-2 bg-green-600 text-white rounded-lg font-medium hover:bg-green-700 transition flex items-center gap-2"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
              </svg>
              Download
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

function FormatButton({
  format,
  selected,
  onClick,
  icon,
  label
}: {
  format: ExportFormat
  selected: boolean
  onClick: () => void
  icon: string
  label: string
}) {
  return (
    <button
      onClick={onClick}
      className={`
        flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition
        ${selected
          ? 'bg-purple-600 text-white shadow-md'
          : 'bg-white text-slate-700 hover:bg-slate-100 border border-slate-300'
        }
      `}
    >
      <span>{icon}</span>
      <span>{label}</span>
    </button>
  )
}
